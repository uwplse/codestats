PARSER_BEGIN(QueryParser)

package edu.washington.cse.codestats;

import edu.washington.cse.codestats.*;

public class QueryParser {
    static List<Query> parse(InputStream f) throws ParseException, TokenMgrError {
         QueryParser parser = new QueryParser(f);
         return parser.Start();
    }
}

PARSER_END(QueryParser)

SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN :
{
  < EXISTS : "exists">
| < COUNT : "count">
| < STMT : "statement">
| < EXPR : "expression">
| < WITHIN : "within">
| < WHERE : "where">
| < AND : "and" >
| < OR : "or" >
| < IS : "is" >
| < IN : "in" >
| < NOT : "not" >
| < ANY : "[?]" >
| < ALL : "[*]" >
| < THIS : "[0]" >
| < IDENT : (["A"-"Z", "a"-"z", "_"])+ >
| < WHATEVER : (["A"-"Z", "a"-"z", "0"-"9", "_", "."])+ >
| < OPERATOR : ("!=" | "==" | "<" | "<=" | ">=" | ">") >
}

List<Query> program() :
{
    List<Query> blocks = new ArrayList();
    Query block;
}
{
    ((block = block()) { blocks.add(block); })* <EOF> { return blocks; }
}

Query block() :
{
    Token name;
    Token deriving = null;
    Metric metric;
    QueryTarget target;
    PredicateMirror pred;
}
{
    (name = <IDENT>) ":" (<EXISTS> { metric = Metric.EXISTS; } | <COUNT> { metric = Metric.SUM; })
    (<EXPR> { target = EXPRESSION; } | <STMT> { target = STATEMENT; })
    <IDENT> [<WITHIN> (deriving = <IDENT>)] <WHERE> "{" (pred = Predicate()) "}"
    { return new Query(name.image, deriving == null ? null : deriving.image, metric, target, pred); }
}

PredicateMirror Predicate() :
{
    PredicateMirror pred;
}
{
    (pred = conjunction())
    { return pred; }
}

PredicateMirror conjunction() :
{
    List<PredicateMirror> children = new ArrayList<PredicateMirror>();
    PredicateMirror child;
}
{
    (child = disjunction()) { children.add(child); }
    (<AND> (child = disjunction()) { children.add(child); } )*
    { return new PredicateMirror(PredicateMirror.PredicateType.AND, children); }
}

PredicateMirror disjunction() :
{
    List<PredicateMirror> children = new ArrayList<PredicateMirror>();
    PredicateMirror child;
}
{
    (child = atom()) { children.add(child); }
    (<OR> (child = atom()) { children.add(child); } )*
    { return new PredicateMirror(PredicateMirror.PredicateType.OR, children); }
}

PredicateMirror atom() :
{
    List<String> attribute = new ArrayList<String>();
    Token component;
    Token target;
    Token operator;
    boolean is;
}
{
    <IDENT> ( "." (component = <IDENT>) { attribute.add(component.image); } | <ANY> { attribute.add("?"); } | <ALL> { attribute.add("*"); } | <THIS> { attribute.add("0"); } )*
    ( (operator = <OPERATOR>) | <IS> ( <NOT> { is = false; } | { is = true; } )) (target = <WHATEVER>)

    {
        PredicateAtom atom;
        if (operator != null) {
            atom = new PredicateAtom(attribute, operator.image, target.image);
        } else {
            atom = new PredicateAtom(attribute, is, target.image);
        }
        return new PredicateMirror(atom);
    }
}